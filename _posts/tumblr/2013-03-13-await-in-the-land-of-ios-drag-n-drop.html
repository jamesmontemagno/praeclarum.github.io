---
layout: post
title:  "Await in the Land of iOS - Drag-n-drop"
date:   2013-03-13 00:54:00 GMT
redirect_from:
  - /post/45231096776
  - /post/45231096776/await-in-the-land-of-ios-drag-n-drop
---


<p>Today is a big day, <a href="http://blog.xamarin.com/brave-new-async-mobile-world/">Xamarin has released</a> (in alpha) support for the <a href="http://msdn.microsoft.com/en-us/library/vstudio/hh156528.aspx">await keyword</a> in C#.</p>


<p>To celebrate, I thought I would write a few articles describing the ways I plan (and now am) taking advantage of that support.</p>


<h3 id="asynccodewithoutawaitiscodewritteninsideout">Async code without await is code written inside out</h3>

<p>Asynchronous programming has taken over our lives. We allowed it to because it benefits software ranging from high performance servers all the way down to responsive UIs on phones. That is to say, it’s good for machines and users.</p>


<p>But async programming comes at a cost for us programmers. It often asks us to mangle our beautiful procedural code into state machines or continuation passing style. We can’t just say “Do A, then B, then C”:</p>

<pre><code>DoA ();
DoB ();
DoC ();
</code></pre>

<p>Instead, we have to write the code using callbacks:</p>

<pre><code>DoA (errA =&gt;
    if (errA != null) HandleError (errA)
    else DoB (errB =&gt;
        if (errB != null) HandleError (errB)
        else DoC ()));
</code></pre>

<p>That code is pretty horrendous compared to the procedural code. It’s too long. It turns our error handling from exception-based to return code-based. The error handling also hides the control flow. It is, quite simply, a mess.</p>


<p>The C# await keyword allows us to write asynchronous procedural code in our preferred style so long we don’t mind a few keywords:</p>

<pre><code>await DoA ();
await DoB ();
await DoC ();
</code></pre>

<p>What a breath of fresh air!</p>


<h3 id="whatelseisinsideout">What else is inside out?</h3>

<p>Await has paid for itself by greatly simplifying our async code. But it made me wonder, what other bits of code am I writing inside out? In other words, what other APIs do I often interact with that are async - that happen in user time, not CPU time?</p>


<p>Event handlers for touch events sprung immediately to mind.</p>


<p>I wondered about an old friend of mine, the drag-n-drop procedure. Dragging objects on the screen is simple:</p>

<ol><li>When a touch begins, look to see if it touches any subviews</li>
<li>If it does, then move that view whenever the touch moves until the touch ends</li>
</ol>
<p>Below is code that I have written 1,268 times (I checked) to implement that procedure in iOS:</p>

<pre><code>class DragInfo
{
    public UITouch Touch;
    public UIView View;
}

readonly Dictionary&lt;UITouch, DragInfo&gt; drags =
    new Dictionary&lt;UITouch, DragInfo&gt; ();

public override void TouchesBegan (NSSet touches, UIEvent evt)
{
    foreach (var touch in touches.ToArray&lt;UITouch&gt; ()) {
        var loc = touch.LocationInView (this);
        var view = Subviews.FirstOrDefault (x =&gt; x.Frame.Contains (loc));

        if (view != null)
            drags[touch] = new DragInfo {
                Touch = touch,
                View = view,
            };
    }
}

public override void TouchesMoved (NSSet touches, UIEvent evt)
{
    foreach (var touch in touches.ToArray&lt;UITouch&gt; ()) {
        DragInfo drag;
        if (!drags.TryGetValue (touch, out drag))
            continue;

        var loc = touch.LocationInView (this);
        var ploc = touch.PreviousLocationInView (this);

        var fr = drag.View.Frame;
        fr.X += (loc.X - ploc.X);
        fr.Y += (loc.Y - ploc.Y);
        drag.View.Frame = fr;
    }
}

public override void TouchesEnded (NSSet touches, UIEvent evt)
{
    foreach (var touch in touches.ToArray&lt;UITouch&gt; ()) {
        DragInfo drag;
        if (drags.TryGetValue (touch, out drag))
            drags.Remove (touch);
    }
}
</code></pre>

<p>It implements multi-touch dragging of views by using some fields to store state between touch events.</p>


<p>How well does this code align with my dragging procedure above? I wrote the code as well as I ever have (i.e. my style hasn’t changed since programming Windows 3.1). But it still has very little resemblance.</p>


<p>The events become the main focus of the code instead of the procedure. I had to introduce a data structure and some mutable, essentially global, data that 3 different functions work with in a coordinated way. Since async methods can be called any time, I just have to hope that I worked out all the possible interleaves in my head (I probably didn’t).</p>


<p>Can we do better? I rewrote that code using <code>await</code> to find out.</p>

<pre><code>// Step 1: Watch for dragging starts
async void WatchForDrags ()
{
    for (;;) {
        var began = await this.GetEventAsync&lt;TouchEventArgs&gt; ("TouchBegan");

        foreach (var t in began.Touches) {
            var loc = t.LocationInView (this);
            var view = Subviews.FirstOrDefault (x =&gt; x.Frame.Contains (loc));

            if (view != null)
                DragView (t, view);
        }
    }
}

// Step 2: Carry-through with the drag until it's over
async void DragView (UITouch touch, UIView view)
{
    for (;;) {
        var moved = this.GetEventAsync&lt;TouchEventArgs&gt; ("TouchMoved");
        var ended = this.GetEventAsync&lt;TouchEventArgs&gt; ("TouchEnded");

        var ev = await Task.WhenAny (ended, moved);

        if (!ev.Result.Touches.Contains (touch))
            continue;

        if (ev == ended)
            return;

        var loc = touch.LocationInView (this);
        var ploc = touch.PreviousLocationInView (this);

        var fr = view.Frame;
        fr.X += (loc.X - ploc.X);
        fr.Y += (loc.Y - ploc.Y);
        view.Frame = fr;
    }
}
</code></pre>

<p>Using a little trick function, I was able to turn normal .NET events into tasks. The idea is simply to subscribe to the event long enough for it to fire once and only once. That one little trick allowed me to increase the readability of the code.</p>


<p>What was 3 functions, 1 data structure, and 1 chunk of memory has been turned into two procedures that align very well to the English procedure above.</p>


<p>I love that this code doesn’t leak its state out into the class containing it. <code>DragInfo</code> is a failure of encapsulation - the data required by the events Began, Moved, Ended was available to all other methods in the class. Now, there is no leaked state. Instead, the state is held in a clojure created when DragView is called by WatchForDrag.</p>


<p>I love that the new code is procedural - lines higher up on the screen happen earlier in time. I love that it processes events in the order that it cares about - no other order.</p>


<p>This is straight procedural code that executes asynchronously in response to user interactions. The machine is happy because I’m not spawning threads, the user is happy because the UI is responsive, and I am happy because I can write code the way I think, not the way I’m required to just to satisfy those other two conditions.</p>


<p>I hope you found this a little interesting. I have a lot more ideas on how to take advantage of <code>await</code> so I hope you’ll stay tuned.</p>


<h3 id="alittletrickfunction">A little trick function</h3>

<p>The GetEventAsync is the magic that allows me to await events. Here is a rough implementation of it.</p>

<pre><code>public static Task&lt;T&gt; GetEventAsync&lt;T&gt; (this object eventSource, string eventName)
    where T : EventArgs
{
    var tcs = new TaskCompletionSource&lt;T&gt;();

    var type = eventSource.GetType ();
    var ev = type.GetEvent (eventName);

    EventHandler handler;

    handler = delegate (object sender, EventArgs e) {
        ev.RemoveEventHandler (eventSource, handler);
        tcs.SetResult ((T)e);
    };  

    ev.AddEventHandler (eventSource, handler);
    return tcs.Task;
}
</code></pre>
